# The Core
The Core contains a single class: Exploit. Exploit contains the following standard non-cmd, non-user-defined, and non-'hidden' functions:   
* connect
* disconnect
* getToken
* rand
* get_shellcode

# Documentation
connect
=======
connect takes no arguments (excluding `self`), and returns a socket object that connects to the defined host.  
Ex: `s = self.connect()`

disconnect
==========
disconnect takes a socket object and closes it.  
Ex: `self.disconnect(s)`

getToken
========
getToken takes a line/string and gives you the first string of characters until it hits a space.  
Ex: `self.getToken("hello world")` => `hello`

rand
====
rand takes an integer that tells how many bytes to randomly generate and returns those generated bytes.  
Ex: `self.rand(2017) # generates 2017 random bytes`

get_shellcode
=============
get_shellcode takes no arguments (excluding `self`) and returns the shellcode found in the file `"framework/payloads/" + self.payload[0]`
# How to write an exploit module

Well, first you have to start off your exploit in the file called framework/modules/osHere/nameHere/nameHere.py with  
`import os, sys`
`sys.path.append(os.path.join(os.path.dirname(__file__), '..', '..', '..'))`
`import core`
`class exploitNameMenu(core.Exploit)`
 in it and the spaces in the name replaced by commas.  
 EX: `framework/modules/windows/pcman_put_overflow/pcman_put_overflow.py`

Next, create an \_\_init\_\_.py file in the same directory with `from nameOfPythonScriptWithout.PyInIt import *` in it.  
Ex: `from pcman_put_overflow import *`

Next, add an entry to the att dictionary in framework/config/config.conf like  
`{otherEntriesOverHere, 'osHere/nameHereWithout.PyInIt':'nameHereWithout.PyInIt:osHere:decriptionOfExploitHere'}`.  
Ex: `{otherEntriesOverHere, 'windows/pcman_put_overflow':'pcman_put_overflow:windows:exploits a buffer overflow in the PCMAN v2.0.7 server.'}`

Now you have to define the generate and deliver methods.

generate
========
The generate function should be defined like this: `def generate(self, payload)`. In it you define how to, well, *generate* your payload. This is required, even if it just does `return ""`.

deliver
=======
The deliver function should be defined like this: `def deliver(self, payload)`. In it you should start off with calling `self.init_deliver()`. This obviously defines how to transfer the payload.

finally
=======
Next, you define a main method outside of your exploit class that looks nearly exactly like:  
`def main():`
`    menu = exploitMenuHere(nameHere, targetHere, payloadHere, variablesHere, descriptionsHere)`
`    menu.cmdloop("pdf-console attack(name)% ")`
, where the name, target, and payload are all strings and variables is a dictionary like `{"host":"", "user":""}` and descriptions is a dictionary like `{"host":"the ip of the target"}`.
Last but not least, you define the part that will let it run as a stand-alone script:  
`if __name__ == '__main__':`
`    main()`

Advanced
========
Some of you out there might want to write modules that don't fit this pattern. Okay. Go ahead. Just keep the cmd functions the same, except possibly for do_start. Good luck!
